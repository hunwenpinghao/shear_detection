1. [✅] 提取roi部分的图片。我们需要提取出 roi 部分图片；

### ROI提取步骤方法：

#### **基础方法** 
- `ImagePreprocessor.extract_roi()` 核心算法：
  ```
  1. 二值化: threshold=30 阈值分离白条状区域与黑背景
  2. 形态学操作: 
     - 闭操作(MORPH_CLOSE)连接断开的白色区域, 核尺寸3x3, 迭代2次  
     - 开操作(MORPH_OPEN)去除小噪点, 核尺寸3x3, 迭代1次
  3. 轮廓检测: 使用findContours找最大外轮廓
  4. 包围盒提取: 添加10像素边距确保完整包含条状物
  ```

#### **关键参数**
- `roi_threshold`: 30（二值化阈值），提高可分离前景背景
- `min_contour_area`: 1000（最小轮廓面积），过滤噪声
- `morphology_kernel`: 3x3（形态学操作核大小）
- 边距：10像素安全余量

#### **处理流程完整管道**
```
原始线阵相机图像 →  
增强对比度(CLAHE) →  
高斯去噪 →  
提取ROI白色条状区域 →  
可选尺寸标准化到(128, 512) → **竖条状线阵格式**  
输出ROI图像+边界框信息
```

#### **ROI质量判断**
- 保证轮廓面积 > min_contour_area=1000
- 自动计算和保存边界框信息 (x,y,w,h)
- 输出图像包含完整的白色条状物区域

2. [] 图像处理提取各个维度特征。我们需要尝试各种传统图像处理中特征提取的方法来从各个方面提取有效特征，例如：纹理特征、灰度图、强对比特征、平滑处理等；以便组合这些特征来做特征工程；

#### **已实现特征提取**
- **基础特征**：撕裂面/剪切面面积比、白斑总数与密度
- **纹理分析**：LBP局部二值模式、表面粗糙度(MORPH_OPEN/Sigma)
- **梯度特征**：Sobel梯度幅值与方向、拉普拉斯边缘检测
- **白斑特征**：连通域分析、面积分布、统计特征(均值/标准差)

🤔 毛刺这个特征怎么处理图像让它更明显？
#### **毛刺增强检测策略 - 已实现**
1. **形态学边缘检测**: `cv2.morphologyEx(MORPH_GRADIENT)` 突出边缘毛刺
2. **高通过滤器**: 拉普拉斯算子 `cv2.Laplacian()` 强调高频毛刺特征
3. **多尺度检测**: 不同高斯核的差分算子检测不同大小毛刺
4. **梯度阈值**: 结合Sobel梯度幅度与阈值突出不规则毛刺边缘
5. **连通域分析**: 毛刺通常形成细长非正常形状连通区域

#### **毛刺检测模块实现总结**
✅ **功能集成**: 新增`detect_burs()`方法到`feature_extractor.py`
✅ **多算法融合**: 结合形态学梯度、拉普拉斯算子、Sobel梯度、多尺度高斯检测
✅ **精细过滤**: 基于伸长率(elongation > 5.0)过滤毛刺形状特征
✅ **双面检测**: 分别检测撕裂面和剪切面的毛刺特征
✅ **可视化展示**: 
   - 毛刺增强图像 (hot colormap)
   - 毛刺二值图 (blue colormap) 
   - 毛刺统计对比图表
✅ **特征参数**: 毛刺数量、密度、平均面积、伸长率、分布均匀性等

#### **关键技术要点**
- **综合权重**: 30% 形态学梯度 + 30% 拉普拉斯 + 20% Sobel阈值 + 20% 多尺度检测
- **形状筛选**: 伸长率>5.0筛选真正的毛刺形状
- **连通域分析**: 基于区域特征的精细分类
- **分割面区分**: 分别检测两个分割面的毛刺特征

#### **聚类算法分离策略 - 已实现**
✅ **多方法聚类分析**: 实现纹理特征聚类，将左半边和右半边分离为独立簇
✅ **horizontal_profiles**: 基于垂直纹理的水平投影分析与波纹边界检测
✅ **K-Means空间聚类**: 融合位置、强度、梯度的多维特征聚类
✅ **层次聚类**: 基于角点特征的区域聚类分析方法
✅ **DBSCAN聚类**: 密度聚类自适应算法，得分最高的方案
✅ **聚类质量评估**: 聚类稳定性、分离质量、关联度系数
✅ **可视化输出**: 2×3维聚类效果对比图，含边界演变过程展示

#### **聚类算法实测结果**
- **horizontal_profiles**: 成功率100%，适合垂直条状纹理
- **kmeans**: 成功率一般，分割质量0.064
- **hierarchical**: 存在维度兼容性需要优化
- **dbscan**: 最佳表现，分离质量1.000，稳定性1.000
- **聚合至特征提取**: 6种聚类特征已集成到完整特征提取流程

3. [✅] 检测分割线。我们需要设计一种方法完美的分割出撕裂面与分割面；当然可以采用传统的图像处理直接计算，也可以尝试各种机器学习的方法，或者尝试分割模型；

#### **已实现的分割检测方法**
1. **直线分割法** (`centerline`): 简单中点分割左右区域
2. **边界检测法** (`boundary`):  基于中央区域梯度最大变化检测固定分割线位置  
3. **曲线拟合分割** (`curved`): **✅ 推荐方法**
   - 逐行梯度检测获得分割点分布
   - 高斯滤波平滑边界点 (σ=2.0) 
   - 多项式拟合生成连续曲线边界  
   - 精确分离撕裂面(左)与剪切面(右)
  
4. **梯度分析法** (`gradient`): Otsu阈值分离高低梯度区域
5. **纹理分析法** (`texture`): K-means聚类纹理特征分区域
6. **混合策略法** (`hybrid`): 融合边界检测(权重2.0)+梯度(权重1.0)+纹理(0.5)

#### **最优曲线分割特点**
- 识别真实的灰色中心分割线形状
- 左右分配准确：左=撕裂面(凹状毛刺)/右=剪切面(平面整洁)
- 零距离贴合实际工件几何形状
- **曲线标准差 ≤4 pixels 最优精度**


4. [✅] 设计高层语义特征指数，例如撕裂面与分割面的比例、撕裂面白色斑块的数量或毛刺数量等。

#### **已实现语义特征指数**
- **撕裂面/剪切面比例 (tear_ratio)**: 关键指标—磨损越重该值越高  
- **白斑密度 (spot_density)**: 每像素白斑数量，撕裂面特有
- **白斑数量统计**: 大小分层统计、总数量与平均面积
- **表面粗糙度指数 (roughness)**: 左右区域对比、差异指标
- **白斑分布均匀性**: 撕裂面vs剪切面分布的sigma值  
- **强度统计指标**: 像素级mean_std_entropy特征  
- **边界光顺度** (boundary smoothness): 形态学梯度检测方法


5. [✅] 模型选择，传统机器学习 or 分割模型 or 检测模型 

#### **当前已实现方案**
- **传统调研算法** ✅ `SimpleShearDetectionModel`
  - 基于规则的专家匹配模型
  - 组合多个特征阈值判断磨损程度  
  - 时间复杂度低，可控度高
  - **风险评分RR ∈[0,1] + 状态建议** 的三分类方案

#### **算法特点对比**
| 模型| 精度| 实时性| 可解释性| 泛化性  |缺点|
|:---------|:--:|:----:|:------:|:----:|:---|
| 传统规制法|⭐⭐⭐ | ===A| ===A| ❌     | 依赖专家经验|
| K-NN/SVM分类|⭐⭐⭐ | ⭐⭐⭐| ❌| ⭐⭐⭐   |黑盒模型|  
| DeepG幕1风格     |⭐   | A| ---| ===A|需要大数据|

#### **推进下一步**
1. [🎯近期]: 当前的有效性验证 → 在生产线上时序检验与调参
2. [📈中期可考]: 如果我们有条件积累更多标注数据 → 探究机器学习(K-NN/SVM/RF)
3. [🍇长远考虑可适当引入计算机视觉分割(DL Segmentation)](模型如UNet/Mask-R-CNN需要大量数据标注)

📋 总结 —–  
我们已在现有 ROI预处理与拓扑特征检测流程基础上搭建了 **稳健的传统方法为基础试点方案**。

---
问题一：白色斑块图是用什么方法得到的？

答案：白色斑块检测采用以下技术组合：

## 核心技术实现：

### 1. 区域限制检测
```
检测区域：仅在撕裂面区域内检测白色斑块
使用cv2.bitwise_and图像，确保只检测撕裂面中的白色区域
```

### 2. 阈值二值化处理
```
阈值设置：config['white_spot_threshold'] = 200
算法：cv2.threshold(masked_image, 200, 255, cv2.THRESH_BINARY)
作用：将图像转为二值图，突出大于200灰度的白色像素
```

### 3. 形态学操作优化
```
去噪方法：椭圆卷积核对图像开运算
内核：cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3, 3))
操作：cv2.morphologyEx(white_binary, cv2.MORPH_OPEN, kernel)
作用：去除小噪点，保留有效白色块
```

### 4. 连通域分析
```
工具：skimage.measure.label + regionprops
步骤：
1. 标记连通区域：labeled_spots = measure.label(white_binary)
2. 提取属性：regions = measure.regionprops(labeled_spots)
```

### 5. 面积过滤
```
最小面积：config['min_spot_area'] = 5 pixels
最大面积：config['max_spot_area'] = 500 pixels
过滤逻辑：遍历所有连通域，仅保留面积在5-500范围内的斑点
```

### 6. 特征提取统计
```
面积计算：total_spot_area = sum(有效斑块面积)
密度评估：spot_density = total_spot_area / tear_area
分布分析：基于重心坐标算标准差衡量整体分布相似性
```

## 参数配置：
```python
'white_spot_threshold': 200,  # 白斑检测阈值(0-255)
'min_spot_area': 5,          # 最小白斑面积
'max_spot_area': 500,        # 最大白斑面积
```

## 输出结果：
```
white_binary_mask: 二值化白斑掩码图像
spot_count: 有效白斑数量
spot_density: 白斑密度
distribution_uniformity: 分布均匀性指数
```

这种多级处理方法确保白斑检测的鲁棒性，可以在撕裂面上准确定位白色麻点并提取统计特征用于后续磨损度分析。

## 代码实现位置：
```
文件路径：data_process/feature_extractor.py
主要函数：detect_white_spots(image, tear_mask)
入口函数：extract_all_features() 调用白斑检测过程

测试结果（示例）：
- spot_count: 29 个白斑块
- spot_density: 0.102 白斑密度  
- average_spot_size: 115.1 pixels 平均斑块大小
```

## 可视化输出：
白斑掩码图已生成在 "白色斑块" 子图中，红色覆盖标识检测到的白斑块区域。


---
问题：纹理图如何生成？

答案：纹理图生成采用多种传统图像处理算法，通过`texture_converter.py`实现：

## 核心技术实现：

### 1. 局部二值模式(LBP)纹理
```
算法：skimage.feature.local_binary_pattern
参数：radius=3, n_points=24, method='uniform'
原理：计算每个像素与邻域像素的局部二值模式
输出：LBP纹理图 + 直方图特征(均值、标准差、熵)
```

### 2. Gabor滤波器纹理
```
算法：cv2.getGaborKernel + cv2.filter2D
参数：frequencies=[0.1,0.2,0.3], orientations=[0,π/4,π/2,3π/4]
原理：多方向多频率的Gabor滤波器响应
输出：Gabor纹理图 + 能量特征
```

### 3. 梯度纹理
```
算法：cv2.Sobel梯度计算
参数：ksize=3, 计算x和y方向梯度
原理：梯度幅度 = sqrt(grad_x² + grad_y²)
输出：梯度纹理图 + 梯度统计特征
```

### 4. 拉普拉斯纹理
```
算法：cv2.Laplacian边缘检测
参数：ksize=3, 计算二阶导数
原理：拉普拉斯算子突出图像中的边缘和细节
输出：拉普拉斯纹理图 + 边缘强度特征
```

### 5. Sobel纹理
```
算法：cv2.Sobel边缘检测
参数：ksize=3, 分别计算x和y方向
原理：Sobel算子检测水平和垂直边缘
输出：Sobel纹理图 + 边缘响应特征
```

### 6. 灰度共生矩阵(GLCM)纹理
```
算法：skimage.feature.graycomatrix + graycoprops
参数：distances=[1,2], angles=[0,π/4,π/2,3π/4], levels=8
原理：计算像素对的空间关系统计特征
输出：GLCM纹理图 + 对比度、均匀性、能量等特征
```

## 处理流程：
```
输入ROI图像 → 
灰度化处理 → 
多种纹理算法并行计算 → 
特征归一化(0-255) → 
生成纹理图像 → 
计算统计特征 → 
综合纹理图融合 → 
可视化对比展示
```

## 参数配置：
```python
texture_methods = ['lbp', 'glcm', 'gabor', 'gradient', 'laplacian', 'sobel']
output_dir = "output/texture_analysis"
```

## 输出结果：
```
texture_lbp.png: LBP纹理图
texture_gabor.png: Gabor纹理图  
texture_gradient.png: 梯度纹理图
texture_laplacian.png: 拉普拉斯纹理图
texture_sobel.png: Sobel纹理图
texture_combined.png: 综合纹理图
texture_visualization.png: 对比可视化图
texture_analysis_report.json: 特征数据报告
```

## 特征统计：
```
LBP特征: 均值18.05, 标准差7.52, 熵3.77
Gabor特征: 均值104.23, 标准差98.24, 能量1.34×10⁹
梯度特征: 均值55.54, 标准差76.73, 最大值429.74
拉普拉斯特征: 均值52.06, 标准差84.23, 最大值858.0
Sobel特征: 均值55.54, 标准差76.73, 最大值429.74
```

## 代码实现位置：
```
文件路径：texture_converter.py
主要类：TextureConverter
入口函数：convert_to_texture(image_path, output_dir, methods)
可视化函数：_create_visualization() 支持中文字体显示
```

## 技术特点：
- **多算法融合**: 6种不同纹理分析方法
- **特征归一化**: 统一输出0-255范围便于对比
- **综合纹理图**: 多方法平均融合生成
- **中文字体支持**: 自动检测系统字体，支持中文标签显示
- **跨平台兼容**: macOS/Windows/Linux字体自动适配

## 纹理方法对剪刀磨损程度检测的适用性分析
**推荐排序（从高到低）**
### 1. LBP纹理（推荐）
原因：对局部纹理变化敏感，能捕捉磨损导致的微观纹理变化
特征：均值18.05、标准差7.52、熵3.77
优势：对磨损产生的细微纹理差异敏感，适合量化磨损程度
### 2. 拉普拉斯纹理（推荐）
原因：突出边缘与细节，磨损会改变边缘锐度
特征：均值52.06、标准差84.23、最大值858.0
优势：磨损会降低边缘锐度，拉普拉斯能有效检测
### 3. Gabor纹理（推荐）
原因：多方向多频率，能捕捉磨损的方向性特征
特征：均值104.23、标准差98.24、能量1.34×10⁹
优势：磨损常具方向性，Gabor能有效表征
### 4. 梯度纹理（中等）
原因：检测强度变化，磨损会改变表面梯度
特征：均值55.54、标准差76.73、最大值429.74
局限：对磨损的细微变化不够敏感
### 5. Sobel纹理（中等）
原因：与梯度类似，主要检测边缘
特征：与梯度纹理相同
局限：对磨损的细微变化不够敏感

---
画出斑块密度和数量随时间变化的曲线图并用滤波器使得曲线更加平滑。
